server_uri: bolt://localhost:7687
database: medverse
admin_user: snowj
admin_pass: abcd1234
files:
  - url: file:///var/lib/neo4j/import/custom_partitions/micro_samplings.csv
    mode: sync
    thread_count: 1
    chunk_size: 5000
    log_step: 100
    cql: |
      WITH $dict.rows as rows UNWIND rows as row
      match (rs:RefSet {id:1710})
      match (lc:LocalConcept {id:rs.code + '|' + row.spec_itemid})
      match (pa:Patient {id:toInteger(row.subject_id)})
  
      with row, lc, pa,
          case when row.charttime is not null and row.charttime <> ''
          then datetime ({epochseconds: apoc.date.parse(row.charttime, 's', 'yyyy-MM-dd HH:mm:ss')}) - pa.shiftedYears
          else datetime ({epochseconds: apoc.date.parse(row.chartdate, 's', 'yyyy-MM-dd HH:mm:ss')}) - pa.shiftedYears
          end as charttime
      create (ms:Measurement:MicroSampling:EXISTENT {specimenId:toInteger(row.micro_specimen_id)})
          set ms.subjectId = toInteger(row.subject_id),
              ms.visitId = case when row.hadm_id is not null and row.hadm_id <> ''
                          then row.hadm_id else row.subject_id + "-" + charttime.epochSeconds end
      create (ms)-[:OF_ITEM]->(lc)
      merge (chartedAnc:Anchor {id:row.subject_id + '-' + charttime.epochSeconds})
          on create
          set chartedAnc.value = charttime
      create (ms)-[:MEAS_CHARTED]->(chartedAnc)
  
      with row, ms, charttime, pa
  
      optional match (pa)-[:HAS_CASE]->()-[:HAS_VIS]->()-[:HAS_STOP]->(stop),
                     (stop)-[:STOP_STARTED]->(startAnc),
                     (stop)-[:STOP_ENDED]->(endAnc)
      where charttime >= startAnc.value and charttime < endAnc.value
  
      with row, ms, charttime, stop
  
      limit 1 // check point
  
      foreach (ignore in case when stop is not null then [1] else [] end |
          create (stop)-[:HAS_MEAS]->(ms)
      )
  
      with row, ms, charttime
      where stop is null
  
      match (pa:Patient {id: toInteger(row.subject_id)})-[:HAS_CASE]->(ca)
  
      with row, ms, charttime, ca
      merge (vis:Visit {id:row.subject_id + '-' + charttime.epochSeconds})
          on create
          set vis.newCreated = true
      merge (stop:Stop {id:row.subject_id + '-' + charttime.epochSeconds})
      create (stop)-[:HAS_MEAS]->(ms)
  
      foreach (ignore in case when vis.newCreated is not null then [1] else [] end |
          remove vis.newCreated
          merge (ca)-[:HAS_VIS]->(vis)
          merge (vis)-[:HAS_STOP]->(stop)
  
  
          merge (stop)-[:HAS_MEAS]->(ms)
  
          merge (startAnc:Anchor {id:row.subject_id + '-' + charttime.epochSeconds})
              on create
              set startAnc.value = charttime
  
          merge (endAnc:Anchor {id:row.subject_id + '-' + (charttime.epochSeconds + 60)})
              on create
              set endAnc.value = charttime + duration({seconds: 60})
  
          merge (vis)-[:VIS_STARTED]->(startAnc)
          merge (vis)-[:VIS_ENDED]->(endAnc)
  
          merge (stop)-[:STOP_STARTED]->(startAnc)
          merge (stop)-[:STOP_ENDED]->(endAnc)
      )


  - url: file:///var/lib/neo4j/import/mimiciv/2.2/hosp/microbiologyevents.csv
    mode: sync
    thread_count: 1
    chunk_size: 5000
    log_step: 100
    cql: |
      WITH $dict.rows as rows UNWIND rows as row
      match (ms:MicroSampling {specimenId: toInteger(row.specimen_id)})-[:MEAS_CHARTED]->(chartedAnc)
      match (rs:RefSet {id: 1706})
      match (orgItem:LocalConcept {id: rs.code + '|' + row.test_itemid})
      with row, ms, orgItem, chartedAnc,
          case when row.org_itemid is not null then row.micro_specimen_id + '-' + row.test_itemid + '-' + row.org_itemid
          else row.micro_specimen_id + '-' + row.test_itemid + '-' + '00000' end as testId

      merge (mt:OrgTesting {testId: testId})
          on create
          set mt.sampleSeq = toInteger(row.test_seq)

      merge (ms)-[:HAS_CONT]->(mt)
      merge (mt)-[:MEAS_CHARTED]->(chartedAnc)
      merge (mt)-[:OF_ITEM]->(orgItem)

      with row, mt, chartedAnc
      match (rs:RefSet {id:1707})
      optional match (orgParam:LocalConcept {id: rs.code + '|' + row.org_itemid})
      optional match (cmt:RefComment {id: row.comments})

      with row, mt, orgParam, cmt, chartedAnc
      foreach (ignore in case when orgParam is not null then [1] else [] end |
          set mt:TEXTUAL,
              mt.valueText = orgParam.value
      )
      foreach (ignore in case when cmt is not null then [1] else [] end |
          set mt.valueCmt = cmt.value
      )

      with row, mt, chartedAnc,
          case when row.isolate_num is not null and row.isolate_num <> "" then toInteger(row.isolate_num) else null end as isolate_num,
          case when row.quantity is not null and row.quantity <> "" then row.quantity else null end as quantity,
          case when row.dilution_comparison = "=>" then ">=" else row.dilution_comparison end as dilution_comparison
      where row.ab_itemid is not null and row.ab_itemid <> ''

      match (abxIRs:RefSet {id:1708})
      match (abxPRs:RefSet {id:1709})
      match (oprRs:RefSet {id:2301})
      match (abxItem:LocalConcept {id: abxIRs.code + '|' + row.ab_itemid})
      optional match (abxOpr:LocalConcept {id: oprRs.code + '|' + row.dilution_comparison})
      optional match (abxParam:LocalConcept {id: abxPRs.code + '|' + row.interpretation})

      with row, mt, chartedAnc, isolate_num, quantity, abxItem, abxOpr, abxParam

      create (abxTest:AbxTesting:Measurement)
      set abxTest.isolateNum = isolate_num,
          abxTest.quantity = quantity
      create (abxTest)-[:MEAS_CHARTED]->(chartedAnc)
      create (abxTest)-[:OF_ITEM]->(abxItem)
      create (mt)-[:HAS_CONT]->(abxTest)

      foreach (ignore in case when row.dilution_value is not null and row.dilution_value <> "" then [1] else [] end |
          set abxTest:NUMERIC,
              abxTest.valueNum = toFloat(row.dilution_value),
              abxTest.valueOpr = abxOpr.value
      )

      foreach (ignore in case when abxParam is not null then [1] else [] end |
          set abxTest:TEXTUAL,
              abxTest.valueText = abxParam.value
      )

post_ingest:
  - |
    match (ms:MicroSampling)-[:MEAS_CHARTED]->(anc)
    match (pa:Patient {id:ms.subjectId})
    with ms, pa, anc.value as charttime
    call {
        with ms, pa, charttime

        optional match (pa)-[:HAS_CASE]->()-[:HAS_VIS]->()-[:HAS_STOP]->(stop),
                       (stop)-[:STOP_STARTED]->(startAnc),
                       (stop)-[:STOP_ENDED]->(endAnc)
        where charttime >= startAnc.value and charttime < endAnc.value

        with ms, charttime, stop

        limit 1 // check point

        foreach (ignore in case when stop is not null then [1] else [] end |
            merge (stop)-[:HAS_MEAS]->(ms)
        )


        with ms, charttime
        where stop is null

        match (pa:Patient {id: ms.subjectId})-[:HAS_CASE]->(ca)

        with ms, charttime, ca
        merge (vis:Visit {id:ms.subjectId + '-' + charttime.epochSeconds})
            on create
            set vis.newCreated = true
        merge (stop:Stop {id:ms.subjectId + '-' + charttime.epochSeconds})
        merge (stop)-[:HAS_MEAS]->(ms)

        foreach (ignore in case when vis.newCreated is not null then [1] else [] end |
            remove vis.newCreated
            merge (ca)-[:HAS_VIS]->(vis)
            merge (vis)-[:HAS_STOP]->(stop)

            merge (startAnc:Anchor {id:ms.subjectId + '-' + charttime.epochSeconds})
                on create
                set startAnc.value = charttime

            merge (endAnc:Anchor {id:ms.subjectId + '-' + (charttime.epochSeconds + 60)})
                on create
                set endAnc.value = charttime + duration({seconds: 60})

            merge (vis)-[:VIS_STARTED]->(startAnc)
            merge (vis)-[:VIS_ENDED]->(endAnc)

            merge (stop)-[:STOP_STARTED]->(startAnc)
            merge (stop)-[:STOP_ENDED]->(endAnc)
        )
    } in transactions of 5000 rows